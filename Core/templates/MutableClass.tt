<#@ template language="C#" inherits="TemplateUtils" #>
<#@ import namespace="org.pescuma.ModelSharp.Core.model" #>
<#@ parameter name="it" type="org.pescuma.ModelSharp.Core.model.TypeInfo" #>
<#@ parameter name="class" type="System.String" #>
// Automatically generated by Model#
// DO NOT EDIT THIS FILE

<# ForEach("CreateUsing", it.Using); #>

<# if (it.Package != null) { #>
namespace <#= it.Package #>
{

<# } #>
<# if (it.Documentation != null) { #>
	/// <summary>
	/// <#= it.Documentation #>
	/// </summary>
<# } #>
<# ForEach("Annotation", it.Annotations); #>
<# ForEach("Annotation", it.BaseOnlyAnnotations); #>
	public abstract class <#= it.ImplementationName #> <# if (it.ExtendsOrImplements.Count > 0) { #>: <# ForEach(it.ExtendsOrImplements, separator: ", "); #> <# } #> 
	{
		#region Field Name Defines

<# if (it.BaseClass.IsGenerated) { #>
		public new class PROPERTIES : <#= it.Extends #>.PROPERTIES
<# } else { #>
		public class PROPERTIES
<# } #>
		{
<# ForEach("Define", it.Properties); #>
		}

		#endregion

		#region Constructors

		public <#= it.ImplementationName #>(<# ForEach("Param", it.ContructorArguments, separator: ", "); #>)
		{
<# ForEach("NotNullIfRequired", it.ContructorArguments); #>
<# ForEach("MutableInitField", it.NonComputedProperties); #>
<# ForEach("MutableParamToField", it.ContructorArguments); #>
		}

<# if (it.Cloneable) { #>
		public <#= it.ImplementationName #>(<#= it.ImplementationName #> other)
<#		if (it.Extends != null) { #>
			: base(other)
<#		} #>
		{
<# ForEach("MutableOtherToField", it.NonComputedProperties); #>
		}

<# } #>
		#endregion

<# ForEach("Property", it.Properties); #>
		public virtual void CopyFrom(<#= it.Name #> other)
		{
<# if (it.BaseClass.HasCopyFrom) { #>
			base.CopyFrom(other);
<# } #>
<# ForEach("MutableOtherCopyToField", it.NonComputedProperties); #>
		}

		#region Property Notification

<# if (!it.BaseClass.HasPropertyChanging) { #>
		public event PropertyChangingEventHandler PropertyChanging;

		protected virtual void NotifyPropertyChanging(string propertyName)
		{
			PropertyChangingEventHandler handler = PropertyChanging;
			if (handler != null)
				handler(this, new PropertyChangingEventArgs(propertyName));
<# ForEach("NotifyDependenciesChanging", it.PropertiesWithDependencies); #>
		}

<# } else if (it.PropertiesWithDependencies.Count > 0) { #>
		protected virtual void NotifyPropertyChanging(string propertyName)
		{
			base.NotifyPropertyChanging(propertyName);
<# ForEach("NotifyDependenciesChanging", it.PropertiesWithDependencies); #>
		}

<# } #>
<# if (!it.BaseClass.HasChildPropertyChanging) { #>
		public event ChildPropertyChangingEventHandler ChildPropertyChanging;
		
		protected virtual void NotifyChildPropertyChanging(string propertyName, object sender, PropertyChangingEventArgs e)
		{
			ChildPropertyChangingEventHandler handler = ChildPropertyChanging;
			if (handler != null)
				handler(sender, new ChildPropertyChangingEventArgs(this, propertyName, e));
<# ForEach("NotifyDependenciesChanging", it.PropertiesWithDependencies); #>
		}

<# } else if (it.PropertiesWithDependencies.Count > 0) { #>
		protected virtual void NotifyChildPropertyChanging(string propertyName, object sender, PropertyChangingEventArgs e)
		{
			base.NotifyChildPropertyChanging(propertyName, sender, e);
<# ForEach("NotifyDependenciesChanging", it.PropertiesWithDependencies); #>
		}

<# } #>
<# if (!it.BaseClass.HasPropertyChanged) { #>
		public event PropertyChangedEventHandler PropertyChanged;

		protected virtual void NotifyPropertyChanged(string propertyName)
		{
<# ForEach("InvalidateComputedDependenciesCache", it.PropertiesWithCachedComputedDependencies); #>
			PropertyChangedEventHandler handler = PropertyChanged;
			if (handler != null)
				handler(this, new PropertyChangedEventArgs(propertyName));
<# ForEach("NotifyDependenciesChanged", it.PropertiesWithDependencies); #>
		}

<# } else if (it.PropertiesWithDependencies.Count > 0) { #>
		protected virtual void NotifyPropertyChanged(string propertyName)
		{
<# ForEach("InvalidateComputedDependenciesCache", it.PropertiesWithCachedComputedDependencies); #>
			base.NotifyPropertyChanged(propertyName);
<# ForEach("NotifyDependenciesChanged", it.PropertiesWithDependencies); #>
		}

<# } #>
<# if (!it.BaseClass.HasChildPropertyChanged) { #>
		public event ChildPropertyChangedEventHandler ChildPropertyChanged;
		
		protected virtual void NotifyChildPropertyChanged(string propertyName, object sender, PropertyChangedEventArgs e)
		{
<# ForEach("InvalidateComputedDependenciesCache", it.PropertiesWithCachedComputedDependencies); #>
			ChildPropertyChangedEventHandler handler = ChildPropertyChanged;
			if (handler != null)
				handler(sender, new ChildPropertyChangedEventArgs(this, propertyName, sender, e));
<# ForEach("NotifyDependenciesChanged", it.PropertiesWithDependencies); #>
		}

<# } else if (it.PropertiesWithDependencies.Count > 0) { #>
		protected virtual void NotifyChildPropertyChanged(string propertyName, object sender, PropertyChangedEventArgs e)
		{
<# ForEach("InvalidateComputedDependenciesCache", it.PropertiesWithCachedComputedDependencies); #>
			base.NotifyChildPropertyChanged(propertyName, sender, e);
<# ForEach("NotifyDependenciesChanged", it.PropertiesWithDependencies); #>
		}

<# } #>
		#endregion
<# if (it.Cloneable) { #>
		
		#region Clone

#pragma warning disable 109
		public new <#= it.Name #> Clone()
#pragma warning restore 109
		{
			return (<#= it.Name #>) ((ICloneable) this).Clone();
		}

		object ICloneable.Clone()
		{
			return new <#= it.Name #>((<#= it.Name #>) this);
		}

		#endregion
<# } #>
<# if (it.NeedOnDeserialization) { #>
		
		#region Serialization

		void IDeserializationCallback.OnDeserialization(object sender)
		{
<#		if (it.Extends != null) { #>
			// Call OnDeserialization in base class if it exists
			if (typeof(<#= it.Extends #>).GetInterface(typeof(IDeserializationCallback).FullName) != null)
			{
				var map = typeof(<#= it.Extends #>).GetInterfaceMap(typeof(IDeserializationCallback));
				map.TargetMethods[0].Invoke(this, new[] { sender });
			}

<#		} #>
<#		ForEach("MutableListenToField", it.NonComputedProperties); #>
		}

		#endregion
<# } #>
	}
<# if (it.Package != null) { #>

}
<# } #>